# Scalars
scalar UUID
scalar Time
scalar DateTime
scalar Date
scalar Upload

# Auth types
type TokenPair {
    accessToken: String!
    refreshToken: String!
}

type AuthUser {
    id: UUID!
    email: String!
    token: String!
}

# Input types
input RequestLoginInput {
    email: String!
}

input VerifyLoginInput {
    token: String!
}

input RefreshTokenInput {
    refreshToken: String!
}

# Common types
type Education {
    id: UUID!
    title: String!
    description: String!
    certificate: String
}

input EducationInput {
    id: UUID!
    title: String!
    description: String!
    certificate: String
}

type Experience {
    id: UUID!
    description: String!
}

input ExperienceInput {
    id: UUID!
    description: String!
}

input CreateEducationInput {
    title: String!
    description: String!
    certificate: String
}

input UpdateEducationInput {
    id: UUID!
    title: String
    description: String
    certificate: String
}

input CreateExperienceInput {
    description: String!
}

input UpdateExperienceInput {
    id: UUID!
    description: String
}

# Specialist types
type SpecialistProfile {
    id: UUID!
    name: String!
    title: String!
    avatar: String
    practices: Int!
    location: String!
    description: String!
    specialties: [String!]!
    education: [Education!]!
    certificates: [Education!]!
    experience: [Experience!]!
    services: [ServiceInfo!]!
    skills: [String!]!
    likes: Int!
    isLiked: Boolean
    rate5: Float
}

type ServiceInfo {
    id: UUID!
    title: String!
    location: String
    description: String!
    contents: String!
    images: [String!]!
    includes: [String!]!
    settings: ServiceSettings!
    tags: [String!]!
    createdAt: Time!
    updatedAt: Time!
}

type SpecialistInfo {
    id: UUID!
    name: String!
    title: String!
    avatar: String
}

input UpdateUserInput {
    email: String!
    bio: String!
    name: String!
    location: String!
    avatar: String
    education: [EducationInput!]!
    certificates: [EducationInput!]!
    experience: [ExperienceInput!]!
}

input CreateSpecialistInput {
    specialties: [String!]!
}

input UpdateSpecialistInput {
    id: UUID!
    name: String
    title: String
    avatar: String
    location: String
    description: String
    specialties: [String!]
    skills: [String!]
    education: [EducationInput!]!
    certificates: [EducationInput!]!
    experience: [ExperienceInput!]!
}

# Service types
type Practice {
    id: UUID!
    slots: Int!
    duration: Int!
    price: Int!
}

type FormatSettings {
    practices: [Practice!]!
    score: Int!
    enabled: Boolean!
}

type BookingSlot {
    time: DateTime!
    slots: Int!
}

type Service {
    id: UUID!
    title: String!
    location: String
    description: String!
    contents: String!
    images: [String!]!
    includes: [String!]!
    specialist: SpecialistInfo!
    settings: ServiceSettings!
    tags: [String!]!
    reviews: [Feedback!]!
    bookings: [Booking!]
    calendarRestrictions: CalendarRestrictions
    createdAt: Time!
    updatedAt: Time!
}

type ServiceSettings {
    video: FormatSettings!
    inPerson: FormatSettings!
}

type Feedback {
    id: UUID!
    author: String!
    avatar: String
    comment: String!
    createdAt: Time!
}

input CreateServiceInput {
    title: String!
    location: String
    description: String!
    contents: String!
    includes: [String!]
    tags: [String!]
    settings: ServiceSettingsInput!
    calendarRestrictions: CalendarRestrictionsInput
}

input UpdateServiceInput {
    id: UUID!
    title: String
    location: String
    description: String
    contents: String
    includes: [String!]
    tags: [String!]
    settings: ServiceSettingsInput
    calendarRestrictions: CalendarRestrictionsInput
}

input ServiceSettingsInput {
    video: FormatSettingsInput!
    inPerson: FormatSettingsInput!
}

input FormatSettingsInput {
    practices: [PracticeInput!]!
    enabled: Boolean!
}

input PracticeInput {
    slots: Int!
    price: Int!
}

# Booking types
type Booking {
    id: UUID!
    startTime: Time!
    endTime: Time!
    date: Date!
    status: BookingStatus!
    createdAt: Time!
    updatedAt: Time!
    isRepeat: Boolean!
    duration: Int!
    format: Format!
    price: Int!
    service: BookingServiceInfo
    specialist: BookingSpecialistInfo
    user: BookingUserInfo
}

type BookingServiceInfo {
    id: String!
    title: String!
    description: String!
}

type BookingSpecialistInfo {
    id: String!
    name: String!
    avatar: String
}

type BookingUserInfo {
    id: String!
    name: String!
    avatar: String
}

enum BookingStatus {
    WAITING
    CONFIRMED
    DECLINED
    FINALIZE
    REQUEST
}

enum Format {
    VIDEO
    IN_PERSON
}

# Calendar types
type CalendarView {
    calendarRestrictions: CalendarRestrictions!
    bookings: [Booking!]
}

type CalendarRestrictions {
    id: UUID!
    gmt: String!
    commons: DayRestrictions!
    restrictions: [Restriction!]
    location: String
}

type DayRestrictions {
    Mon: Restriction!
    Tue: Restriction!
    Wed: Restriction!
    Thu: Restriction!
    Fri: Restriction!
    Sat: Restriction!
    Sun: Restriction!
}

type Restriction {
    id: ID!
    date: DateTime
    isActive: Boolean!
    intervals: [Interval!]!
    isPractice: Boolean!
}

type Interval {
    start: Time!
    end: Time!
    formats: [Format!]!
}

input CreateCalendarInput {
    calendarRestrictions: CalendarRestrictionsInput!
    hat: UserHat!
}

input UpdateCalendarInput {
    calendarRestrictions: CalendarRestrictionsInput!
    hat: UserHat!
}

input CalendarRestrictionsInput {
    id: UUID!
    gmt: String!
    commons: DayRestrictionsInput!
    restrictions: [RestrictionInput!]!
    location: String
}

input DayRestrictionsInput {
    Mon: RestrictionInput!
    Tue: RestrictionInput!
    Wed: RestrictionInput!
    Thu: RestrictionInput!
    Fri: RestrictionInput!
    Sat: RestrictionInput!
    Sun: RestrictionInput!
}

input RestrictionInput {
    id: ID!
    name: String!
    date: Date
    isActive: Boolean!
    intervals: [IntervalInput!]!
    isPractice: Boolean!
}

input IntervalInput {
    start: Time!
    end: Time!
    formats: [Format!]!
}

input BookSlotInput {
    serviceId: UUID!
    datetime: DateTime!
    format: Format!
    hat: UserHat!
    chatId: UUID!
}

input BookingSlotsInput {
    serviceId: UUID!
    currentBookingId: UUID
}

input RebookSlotInput {
    id: UUID!
    oldDateTime: DateTime!
    newDateTime: DateTime!
    hat: UserHat!
}

# User types
type User {
    id: UUID!
    email: String!
    bio: String!
    name: String!
    location: String!
    avatar: String
    timezone: String!
    createdAt: Time!
    preferences: UserPreferences
    education: [Education!]!
    certificates: [Education!]!
    experience: [Experience!]!
    specialistProfile: SpecialistProfile
    isSpecialist: Boolean!
    hat: UserHat!
    tier: UserTier!
    practice: Int!
}

type UserPreferences {
    language: Language!
    theme: String!
}

enum Language {
    RU
    EN
}

enum UserHat {
    MASTER
    ADEPT
    SUPERVISER
}

enum UserTier {
    UNLIMITED
    PREMIUM
    BASIC
}

enum AIMessageType {
    INFO
    WARNING
    SERVICE
    BOOKING
}

# Dashboard types
type Activity {
    id: UUID!
    startTime: Time!
    endTime: Time!
    date: Date!
    status: BookingStatus!
    createdAt: Time!
    updatedAt: Time!
    isRepeat: Boolean!
    duration: Int!
    format: Format!
    price: Int!
    service: BookingServiceInfo
    specialist: BookingSpecialistInfo
    user: BookingUserInfo
    practiceCount: Int!
}

type ClientInfo {
    id: UUID!
    name: String!
    avatar: String
}

type DashboardStats {
#    topStats: TopStats!
#    practiceOverview: PracticeOverview!
    hat: UserHat!
    upcomingActivities: [Activity!]
}

type TopStats {
    activePracticesCount: Int!
}

type PracticeOverview {
    confirmedSlots: Int!
    newInitiants: Int!
    personalMeetings: Int!
    repeatingMeetings: Int!
}

# Upload types
type UploadResult {
    success: Boolean!
    url: String
    error: String
}

type MultipleUploadResult {
    success: Boolean!
    urls: [String!]
    error: String
}

input AddChatInput {
    id: UUID!
    isAiChat: Boolean!
    message: MessageInput!
    specialistId: UUID
}

input MessageInput {
    chatId: UUID!
    content: String!
    timestamp: DateTime!
    hat: UserHat!
}

# Chat types
type Chat {
    id: UUID!
    isAiChat: Boolean!
    messages: [Message!]!
    specialistId: UUID
    timestamp: DateTime!
    status: BookingStatus
    description: String
    hasNew: Boolean!
    avatar: String
}

type Message {
    id: UUID!
    content: String!
    timestamp: DateTime!
    isFromUser: Boolean!
    chatId: UUID!
    createdAt: Time!
    updatedAt: Time!
    footerContent: String
    aiMessageType: AIMessageType
    specialistIDs: [UUID!]
}

type Chats {
    hat: UserHat!
    chats: [Chat!]!
}

input BaseAnswerInput {
    question: String!
    answer: String!
}

input VersionAnswerInput {
    question: String!
    answer: Int!
}

input PersonalityTestInput {
    v: Int!
    baseQuestions: [BaseAnswerInput!]!
    versionQuestions: [VersionAnswerInput!]!
}

# Mutations
type Mutation {
    # Auth mutations
    requestLogin(input: RequestLoginInput!): Boolean!
    verifyLogin(input: VerifyLoginInput!): TokenPair!
    refreshToken(input: RefreshTokenInput!): TokenPair!
    logout: Boolean!

    testLogin(input: RequestLoginInput!): TokenPair!

    # User mutations
    updateUser(input: UpdateUserInput): Boolean!
    pushPersonalityTest(input: PersonalityTestInput): Boolean!
    
    # Specialist mutations
    upscaleToSpecialist(input: CreateSpecialistInput!): TokenPair!
    updateSpecialist(input: UpdateSpecialistInput!): SpecialistProfile!
    like(id: UUID!): Boolean!
    dislike(id: UUID!): Boolean!

    # Service mutations
    createService(input: CreateServiceInput!): Boolean!
    updateService(input: UpdateServiceInput!): Boolean!

    # Calendar mutations
    createCalendar(input: CreateCalendarInput!): Boolean!
    updateCalendar(input: UpdateCalendarInput!): Boolean!

    # Booking mutations
    bookSlot(input: BookSlotInput!): Boolean!
    rebookSlot(input: RebookSlotInput!): Boolean!
    burnBooking(id: UUID!): Boolean!
    approveBooking(id: UUID!, hat: UserHat!): Boolean!
    completeBooking(id: UUID!, hat: UserHat!): Boolean!

    # Upload mutations
#    uploadCertificate(file: Upload!): UploadResult!
#    uploadEducation(file: Upload!): UploadResult!
#    uploadServicePhotos(files: [Upload!]!): MultipleUploadResult!
#    uploadUserPhoto(file: Upload!): UploadResult!
#    uploadSpecialistPhoto(file: Upload!): UploadResult!

    # Chat mutations
    addChat(input: AddChatInput!): Boolean!
    pushMessage(input: MessageInput): Boolean!
    ackMessages(hat: UserHat): Boolean!
}

# Queries
type Query {
    # Auth queries
    me: User!
    user(id: UUID!): User!
    
    # Specialist queries
    specialist(id: UUID!): SpecialistProfile
    likedSpecialists: [SpecialistProfile!]!

    # Service queries
    service(id: UUID!): Service!

    # Calendar queries
    calendar(hat: UserHat!): CalendarView

    # Activity queries
    dashboard: [DashboardStats!]
}

# Subscriptions
type Subscription {
    # Chat subscriptions
    newChatMessages: [Chats!]!
    bookingSlots(input: BookingSlotsInput): [BookingSlot!]!
}